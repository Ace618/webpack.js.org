"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[9317],{9317:function(e,a,n){n.r(a),n(7378);var t=n(2682),r=["components"];function p(){return p=Object.assign?Object.assign.bind():function(e){for(var a=1;a<arguments.length;a++){var n=arguments[a];for(var t in n)Object.prototype.hasOwnProperty.call(n,t)&&(e[t]=n[t])}return e},p.apply(this,arguments)}function l(e){var a=e.components,n=function(e,a){if(null==e)return{};var n,t,r=function(e,a){if(null==e)return{};var n,t,r={},p=Object.keys(e);for(t=0;t<p.length;t++)n=p[t],a.indexOf(n)>=0||(r[n]=e[n]);return r}(e,a);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(t=0;t<p.length;t++)n=p[t],a.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}(e,r);return(0,t.kt)("wrapper",p({components:a},n),(0,t.kt)("p",null,"Webpack 提供了多种接口来自定义编译过程。\n接口间存在一些重叠功能，例如配置选项可能通过 CLI 标志启用，\n而其他仅存在于单个接口。\n以下概念可以帮助你快速入门。"),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"cli",parentName:"h2"}),"CLI",(0,t.kt)("a",{href:"#cli","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"命令行界面（CLI），\n用于配置构建并与之交互。它在早期原型制作和性能分析的情况下特别有用。\n大多数情况下，\nCLI 只是用于通过配置文件和一些标志（例如",(0,t.kt)("inlineCode",{parentName:"p"},"--env"),"）来启动进程。"),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/cli",parentName:"p"},"了解更多关于 CLI 的知识！")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"module",parentName:"h2"}),"模块",(0,t.kt)("a",{href:"#module","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"使用 webpack 处理模块时，\n最重要的是理解不同的模块语法 -\n特别是受支持的",(0,t.kt)("a",{href:"/api/module-methods",parentName:"p"},"方法"),"和",(0,t.kt)("a",{href:"/api/module-variables",parentName:"p"},"变量"),"。"),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/module-methods",parentName:"p"},"了解更多关于模块的知识！")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"node",parentName:"h2"}),"Node",(0,t.kt)("a",{href:"#node","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"尽管大多数用户可以借助 CLI 和配置文件控制编译，\n通过 Node 接口可以实现更细粒度的控制。\n这包括传递多个配置、\n以程序的方式运行、查阅并收集统计信息。"),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/node",parentName:"p"},"了解更多关于 Node API 的知识！")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"loaders",parentName:"h2"}),"Loaders",(0,t.kt)("a",{href:"#loaders","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"Loaders 用于对模块的源代码进行转换。\n它们被编写成一类将源代码作为参数传入，\n并将编译转换后的新版本代码传出的函数体。"),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/loaders",parentName:"p"},"了解更多关于 loaders 的知识！")),(0,t.kt)("h2",null,(0,t.kt)("span",{id:"plugins",parentName:"h2"}),"插件",(0,t.kt)("a",{href:"#plugins","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,t.kt)("span",{className:"header-link",parentName:"a"}))),(0,t.kt)("p",null,"插件接口允许用户直接介入编译过程。\n插件可以在不同时期运行的生命周期挂钩上注册回调函数。\n在单个编译流程中，当每个钩子都被执行后，插件将拥有\n当前编译流程的完整访问权限。"),(0,t.kt)("p",null,(0,t.kt)("a",{href:"/api/plugins",parentName:"p"},"了解更多关于插件的知识！")))}l.isMDXComponent=!0,a.default=l}}]);