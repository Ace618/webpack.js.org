"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[7154],{7154:function(e,t,n){n.r(t),n(7378);var a=n(2682),r=["components"];function p(){return p=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},p.apply(this,arguments)}function c(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},p=Object.keys(e);for(a=0;a<p.length;a++)n=p[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var p=Object.getOwnPropertySymbols(e);for(a=0;a<p.length;a++)n=p[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}(e,r);return(0,a.kt)("wrapper",p({components:t},n),(0,a.kt)("p",null,"每当一个文件依赖另一个文件时，webpack 都会将文件视为直接存在 ",(0,a.kt)("em",{parentName:"p"},"依赖关系"),"。这使得 webpack 可以获取非代码资源，如 images 或 web 字体等。并会把它们作为 ",(0,a.kt)("em",{parentName:"p"},"依赖")," 提供给应用程序。"),(0,a.kt)("p",null,"当 webpack 处理应用程序时，它会根据命令行参数中或配置文件中定义的模块列表开始处理。\n从 ",(0,a.kt)("a",{href:"/concepts/entry-points/",parentName:"p"},(0,a.kt)("em",{parentName:"a"},"入口"))," 开始，webpack 会递归的构建一个 ",(0,a.kt)("em",{parentName:"p"},"依赖关系图"),"，这个依赖图包含着应用程序中所需的每个模块，然后将所有模块打包为少量的 ",(0,a.kt)("em",{parentName:"p"},"bundle")," —— 通常只有一个 —— 可由浏览器加载。"),(0,a.kt)("aside",{className:"tip"},(0,a.kt)("h6",{className:"tip__prefix",parentName:"aside"},"提示"),(0,a.kt)("p",{parentName:"aside"},"对于 ",(0,a.kt)("em",{parentName:"p"},"HTTP/1.1")," 的应用程序来说，由 webpack 构建的 bundle 非常强大。当浏览器发起请求时，它能最大程度的减少应用的等待时间。而对于 ",(0,a.kt)("em",{parentName:"p"},"HTTP/2")," 来说，你还可以使用",(0,a.kt)("a",{href:"/guides/code-splitting/",parentName:"p"},"代码分离"),"进行进一步优化。")))}c.isMDXComponent=!0,t.default=c}}]);