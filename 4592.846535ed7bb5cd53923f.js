"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[4592],{4592:function(e,t,n){n.r(t),n(7378);var a=n(2682),p=["components"];function l(){return l=Object.assign?Object.assign.bind():function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e},l.apply(this,arguments)}function r(e){var t=e.components,n=function(e,t){if(null==e)return{};var n,a,p=function(e,t){if(null==e)return{};var n,a,p={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(p[n]=e[n]);return p}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(p[n]=e[n])}return p}(e,p);return(0,a.kt)("wrapper",l({components:t},n),(0,a.kt)("p",null,"在为核心仓库贡献代码，编写 loader/plugin，又或是处理复杂的项目时，调试工具将会成为工作流程的重心。无论问题是大型项目的性能下降还是无用追溯，以下工具都可以使这些问题变得不那么痛苦。"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{href:"/api/node/#stats-object",parentName:"li"},"Node")," 和 ",(0,a.kt)("a",{href:"/api/cli/#common-options",parentName:"li"},"CLI")," 提供的 ",(0,a.kt)("a",{href:"/api/stats",parentName:"li"},(0,a.kt)("inlineCode",{parentName:"a"},"stats")," 数据"),"。"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("inlineCode",{parentName:"li"},"node-nightly")," 和 Node.js 最新版本提供的 Chrome ",(0,a.kt)("strong",{parentName:"li"},"DevTools"),"。")),(0,a.kt)("h2",null,(0,a.kt)("span",{id:"stats",parentName:"h2"}),"Stats",(0,a.kt)("a",{href:"#stats","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,a.kt)("span",{className:"header-link",parentName:"a"}))),(0,a.kt)("p",null,"无论你是想手动还是使用工具来筛选 ",(0,a.kt)("a",{href:"/api/stats",parentName:"p"},"这些数据"),"，",(0,a.kt)("inlineCode",{parentName:"p"},"stats")," 数据在调试构建的问题时都非常有用。我们不会在此处深入介绍，请参阅 ",(0,a.kt)("a",{href:"/api/stats",parentName:"p"},"此页面")," 以了解详细内容。但应该知道可以使用它来查找以下信息："),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"每个模块的内容。"),(0,a.kt)("li",{parentName:"ul"},"每个 chunk 中包含的模块。"),(0,a.kt)("li",{parentName:"ul"},"每个模块编译(compilation)和解析的 stats。"),(0,a.kt)("li",{parentName:"ul"},"构建错误和警告。"),(0,a.kt)("li",{parentName:"ul"},"模块之间的关系。"),(0,a.kt)("li",{parentName:"ul"},"其他更多……")),(0,a.kt)("p",null,"最重要的是，",(0,a.kt)("a",{href:"https://github.com/webpack/analyse",parentName:"p"},"官方分析工具")," 和 ",(0,a.kt)("a",{href:"/guides/code-splitting/#bundle-analysis",parentName:"p"},"各种其他分析工具")," 会将这些数据展示为多种形式的可视化图表。"),(0,a.kt)("h2",null,(0,a.kt)("span",{id:"devtools",parentName:"h2"}),"DevTools",(0,a.kt)("a",{href:"#devtools","aria-hidden":"true",tabIndex:"-1",parentName:"h2"},(0,a.kt)("span",{className:"header-link",parentName:"a"}))),(0,a.kt)("p",null,"虽然在简单场景中，可能 ",(0,a.kt)("a",{href:"https://nodejs.org/api/console.html",parentName:"p"},(0,a.kt)("inlineCode",{parentName:"a"},"console"))," 语句会表现良好，然而有时还需要更加强大的解决方案。正如大多数前端开发人员已经知道的，将 Chrome DevTools 用在调试 web 应用程序，是一个能够解救我们的实用工具，",(0,a.kt)("strong",{parentName:"p"},"但它并没有局限于调试 web 应用程序"),"。从 Node v6.3.0+ 开始，开发人员可以使用内置的 ",(0,a.kt)("inlineCode",{parentName:"p"},"--inspect")," 标记以使用 DevTools 调试 Node.js 应用程序。"),(0,a.kt)("p",null,"这可以帮助轻松创建断点、调试内存使用情况、在控制台中暴露和检查对象等。在这个简短的演示中，我们将利用 ",(0,a.kt)("a",{href:"https://github.com/hemanth/node-nightly",parentName:"p"},(0,a.kt)("inlineCode",{parentName:"a"},"node-nightly"))," 包，它提供最新和强大的检测能力。"),(0,a.kt)("aside",{className:"warning"},(0,a.kt)("h6",{className:"warning__prefix",parentName:"aside"},"警告"),(0,a.kt)("p",{parentName:"aside"},"从 v6.3.0 开始，",(0,a.kt)("inlineCode",{parentName:"p"},"--inspect")," 接口就一直可用，因此可以尝试使用本地版本的 npm 包，但要注意某些功能和标记，可能与这里演示中的版本有所不同。")),(0,a.kt)("p",null,"首先在全局安装："),(0,a.kt)("pre",null,(0,a.kt)("code",{className:"hljs language-bash",parentName:"pre"},(0,a.kt)("span",{className:"token function",parentName:"code"},"npm")," ",(0,a.kt)("span",{className:"token function",parentName:"code"},"install")," --global node-nightly")),(0,a.kt)("p",null,"现在，需要运行一次以结束安装："),(0,a.kt)("pre",null,(0,a.kt)("code",{className:"hljs language-bash",parentName:"pre"},"node-nightly")),(0,a.kt)("p",null,"现在，我们可以直接使用带有 ",(0,a.kt)("inlineCode",{parentName:"p"},"--inspect")," 标记的 ",(0,a.kt)("inlineCode",{parentName:"p"},"node-nightly"),"，在任何基于 webpack 的项目中开始构建。注意，我们不应该运行 NPM ",(0,a.kt)("inlineCode",{parentName:"p"},"scripts"),"，例如 ",(0,a.kt)("inlineCode",{parentName:"p"},"npm run build"),"，所以需要指定完整的 ",(0,a.kt)("inlineCode",{parentName:"p"},"node_modules")," 路径："),(0,a.kt)("pre",null,(0,a.kt)("code",{className:"hljs language-bash",parentName:"pre"},"node-nightly --inspect ./node_modules/webpack/bin/webpack.js")),(0,a.kt)("p",null,"应该输出类似如下内容："),(0,a.kt)("pre",null,(0,a.kt)("code",{className:"hljs language-bash",parentName:"pre"},"Debugger listening on ws://127.0.0.1:9229/c624201a-250f-416e-a018-300bbec7be2c\nFor ",(0,a.kt)("span",{className:"token builtin class-name",parentName:"code"},"help")," see https://nodejs.org/en/docs/inspector")),(0,a.kt)("p",null,"现在，在浏览器中访问 ",(0,a.kt)("inlineCode",{parentName:"p"},"chrome://inspect"),"，你会看到在 ",(0,a.kt)("strong",{parentName:"p"},"Remote Target")," 标题下可以进行审查（inspect）的活动脚本。单击每个脚本下自动连接会话的“inspect”链接，会打开一个专门用于 debugger 或 ",(0,a.kt)("strong",{parentName:"p"},"Open dedicated DevTools for Node")," 链接。除此之外还可以看到 ",(0,a.kt)("a",{href:"https://chrome.google.com/webstore/detail/nodejs-v8-inspector-manag/gnhhdgbaldcilmgcpfddgdbkhjohddkj",parentName:"p"},"NiM 扩展程序"),"，这是一个方便的 Chrome 插件。每当通过 ",(0,a.kt)("inlineCode",{parentName:"p"},"--inspect")," 调试某个脚本时，都会自动打开 DevTools 标签页。"),(0,a.kt)("p",null,"我们推荐使用 ",(0,a.kt)("inlineCode",{parentName:"p"},"--inspect-brk")," 标记，此标记将在脚本的第一条语句处断开，以便你可以在源代码中设置断点，并根据需要启动/停止构建。此外不要忘记仍然可以向脚本传递参数。例如，如果你有多个配置文件，你可以通过 ",(0,a.kt)("inlineCode",{parentName:"p"},"--config webpack.prod.js")," 指定想要调试的配置。"))}r.isMDXComponent=!0,t.default=r}}]);